## 变量
**变量**：是"松散类型"的。  “全局变量”和“局部变量”

 **全局变量**：全局作用域下创建的变量。
 
 **局部变量**：私有作用域中创建的变量就是私有变量（局部变量）。
1. 所谓松散类型就是可以保存各种类型的数据。
2. 换句话说变量就是用来保存值的一个“占位符”而已。
3. 定义变量的时候要是用【var操作符】声明一下，后面跟变量名（也就是标识符）
4. 只声明没有初始化：变量会自动保存一个值undefined。
5. 变量初始化就是给变量赋值，变量名不代表任何数据类型，数据类型是由变量值决定的
6. 最好不要修改变量所保存的值得类型，尽管完全有效。
7. 用var操作符定义的变量，将会成为定义该变量的作用域中的**局部变量**。也就是说在函数中使用var 定义一个变量，这个变量就会成为这个作用域的局部变量；这个变量在函数退出后就会自动销毁。
8. 在一个函数中省略var定义变量 ，相当于创建了一个全局变量（相当于在window中创建了一个变量），这样只要调用过一次这个函数，这个变量就有了定义，从而就可以在函数外部任何一个地方获取该变量了。但是这种变量很难维护。
9. 可以使用一条语句定义多个变量:`var message10="hi10",found10 = false,age10=10`;
10. 在严格模式下，不能定义名为eval或者arguments的变量，否则会导致语法错误。


**私有变量**
```javascript
function test7() {
  var message7="hi7";//局部变量
  console.log(message7);//hi7
}
test7();
//函数执行会形成一个私有作用域，这个私有作用域会保护其中的私有变量不受外界影响。
//（这种机制就是闭包）
//这个函数的执行过程：
//1、当函数执行的时候，会开辟一个私有作用域；
//2、创建变量message7并且为其赋值
//3、输出变量message7
//4、函数执行完之后，这个私有作用域会立即销毁。
console.log(message7);//Uncaught ReferenceError: message7 is not defined
//因为函数执行完之后，函数私有作用域就会立即销毁，所以console.log(message7)会报错。
```
> 问：如何保留这个message7呢？
```javascript
function test7() {
   message7="hi7";
   console.log(message7);//hi7
}
test7();
console.log(message7);//hi7
console.log(this);//window
```

## 数据类型赋值过程
### 引用数据类型赋值过程
1. 浏览器先给开辟一块堆内存
2.  如果是对象那么就把键值对当字符串存入到这个内存中，如果是函数那么就把函数体内的代码当作字符串存入内存中
3.  最后把这个地址返回
```javascript
console.log(total); 
// undefined 因为total在下面定义了，会提前预解释，
// 所以不会报错，但是在这一行还没有赋值，所以是undefined
function sum(num1, num2) {
    console.log(total); // 0        
    // 因为sum这个函数是在定义之后才执行的
    total = num1 + num2; // 0 => 3
    console.log(total); // 3
}
sum(1, 2);
// undefined 3  
// 第一次执行这个函数的时候，变量total在当前作用域中不存在，
// 向上查找，找到total，因为变量提升找到了total，但是现在还没赋值，
// 所以输出undefined，第二行total = num1+num2 ；total = 1+2；
// 也就是将全局变量total赋值3，所以输出3
var total = 0;
//在这里将全局变量total重新赋值了0
sum(1, 2);//0  3  
// 所以在这里执行函数，输出 0 ，和 3
console.log(total); //3  在这输出的就是全局变量的最后值
```

```javascript
var num = 10;
var obj = {
   num : 10,
   fn : function (){},
   num1 : obj.num // 在赋值的过程中不能使用obj当前变量，，因为在这里obj这个变量对应的对象，还没有形成，所以找不到obj
}
// Cannot read property 'num' of undefined
```


## 变量提升
1. 在代码执行前，浏览器会先把带有var的变量和function中的参数提前声明（注意：只是声明。没有赋值）
2. let不存在变量提升
3. 用var声明的变量只是声明没有赋值。浏览器会默认复制undefined。
4. 用function定义的函数，在函数执行的时候可以赋值，如果执行函数的时候不传参数，默认undefined。

> 变量提升的实例
> - 函数声明方式定义的函数名会预解释（也就是变量提升）。
> - 函数表达式方式定义的函数不存在函数提升。（因为var只是变量提升，不会提前赋值。）
````javascript
console.log(num); // undefined => 打印并没有报错，说明num已经被声明过。
console.log(sum); // 函数体 => 说明赋值也结束了
var num = 5;
console.log(num)//5
function sum(num1,num2) {
    console.log(arguments);; // Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    console.log(arguments[0]);; // 1
    console.log(arguments[1]);; // 2
    return;//函数中遇到return，就不会在执行后面的代码
    console.log(num1);
    console.log('sum');
}
sum(1,2)
````
2
```javascript
var num2 = 100; //  num2是全局变量
function foo(){
   //console.log(fn);
   //console.log(num2);
   num2 += 1000; //num2 = num2+1000  问：这个num2从何而来，这就关系到作用域链的知识点了，想用这个变量，就得先看看这个变量是否声明，在哪里声明的，先看一看在当前作用域中是否声明，如果有直接用，若果没有就向上一级作用域查找。
   function fn(){}
   var num2; // 私有变量 定义在函数内部的变量， num2 = num2 + 1000; num2 = undefined + 1000;
   console.log(num2); // NaN
}
console.log(num2); // 100
foo(); // 此刻执行也只是把foo内部自己的私有num2修改。全局依然是100
console.log(num2); // 100
```
3
```javascript
 //因为变量a使用var声明的，在代码执行前会存在变量提升，var a；但是赋值不会提升，所以在赋值之前的a = undefined
 console.log(a); // undefined
    var a = [100, 200]; // [100,200,300]
    console.log(a);//[100,200]
    function fn() {//如果将a作为参数传入函数，那结果又不一样了
        //函数执行会形成一个私有作用域，私有作用域中的数据会保护变量不受外界的影响。
        //函数执行过程，会存在变量提升，也就是会先查找var声明的变量，以下包括var c；然后从上到下依次执行函数中的代码，第一行代码就关系到数据变量a，由于当前作用与中没有声明a的值，会沿着作用域链向上一级作用域查找，找到var a = [100,200]；
        //var a = [100,200]:a这个变量保存的是引用数据类型数组[100,200]的引用地址
        a[a.length] = 300; // 对变量对应的引用地址中的数据进行操作（在数组末尾添加了一个值300）
        console.log(a);
        //操作的还是全局变量中的a的值
        a = a.slice(); // slice复制  不改变原数组  // a = [100,200,300];
        a[a.length] = 400; // [100,200,300,400]
        console.log(a);
        //var a;
        var c = 55; // 这个声明c的动作在形参赋值阶段已经结束。但是这个赋值动作还是要执行的。
    }
    fn(); // 函数
    console.log(a);
```


## 堆内存&栈内存
JS中的内存一共两种：堆内存和栈内存
### 堆内存
**作用**：用来存储引用数据类型值的内存空间叫做堆内存（对象存储的是键值对，函数存储的是代码字符串）

**形成**：只要遇到对象/数组/正则/函数等引用类型的值，浏览器首先第一步就是创建一个堆内存…

**释放**：如果当前的堆内存被变量（或者函数以及元素事件等）占用了（占用了：堆内存地址赋值给变量了），此时的堆内存是有用的，不能销毁；我们想要手动释放堆内存，只需要让存储地址的变量等于其它值即可（最好等于null，null是空对象指针，本意就是不指向任何的堆内存）；

1. var o={name:'王伟'};//<=> o=AAAFFF000
2. o = null;//=> 此时堆内存不被占用，浏览器会在空闲的时间，把所有不被占用的堆内存进行自动回收释放（谷歌浏览器的机制，IE浏览器是靠计数器来统计当前堆内存被占用的次数：当计数器统计为零次，说明没有人占用它，浏览器销毁这个堆内存）


### 栈内存
**作用**：又称为`作用域`，目的就是提供JS代码执行的环境（供代码执行的），基本数据类型值都是直接的存储在栈内存中

**全局作用域（栈内存）**：

**形成**：浏览器渲染页面，首先就会形成一个全局作用域

**销毁**：关闭当前页面（F5刷新页面：先把页面关闭，然后再重新打开）

**私有作用域（栈内存）**：

**形成**：函数执行会形成私有的作用域

**销毁**：一般情况下，函数体中的代码执行完成，形成的栈内存会立即释放；当然也有不释放的情况，后面再详细来讲。

## 闭包
闭包作用（保存）
函数执行形成一个私有作用域，函数执行完成，形成的这个栈内存一般情况下都会自动释放

但是还有二般情况：函数执行完成，当前私有作用域（栈内存）中的某一部分内容被栈内存以外的其它东西（变量/元素的事件）占用了，当前的栈内存就不能释放掉，也就形成了不销毁的私有作用域（里面的私有变量也不会销毁）

i++和++i的区别

i++：先拿原有i的值和其它值进行运算，运算完成后在自身累加1
++i：先自身累加1，然后拿累加完成的结果和其它值进行运算

1.var i=5;
2.console.log(5+i++);//->10  5+(i++) 加括号也是先运算在累加1
3.console.log(i);//->6
4.
5.i=5;
6.console.log(5+(++i));//->11
7.console.log(i);//->6
函数执行形成一个私有作用域，如果私有作用域中的部分内容被以外的变量占用了，当前作用域不销毁

[形式]
函数执行返回了一个引用数据类型堆内存的地址（并且堆内存隶属于这个作用域），在外面有一个变量接收了这个返回值，此时当前作用域就不能销毁（想要销毁，只需要让外面的变量赋值为null，也就是不占用当前作用域中的内容了）

1.function fn() {
2.    var i = 1;
3.    return function (n) {
4.        console.log(n + i++);
5.    }
6.}
7.var f = fn();
8.f(10);//->11
9.fn()(10);//->11
10.f(20);//->22
11.fn()(20);//->21

## 函数执行的过程

## 作用域

## 作用域链

## 执行环境
## 执行环境
每一个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。

## 全局执行环境
全局执行环境是最外层的一个执行环境，在浏览器中全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。
- 当一个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之被销毁。
- 全局执行环境直到退出应用程序时才会被销毁。
- 每一个函数都有自己的执行环境。

## 作用域链
代码在环境中执行的时候，会创建一个变量对象的作用域链。

1. [用途]:保证对执行环境有权访问的所有变量和函数的有序访问。
2. 作用域链的前端，始终都是当前执行的代码所在环境的变量对象。
3. 如果这个环境是“函数”，“变量对象”是他的“活动对象”。活动对象在最开始时，只包含一个变量，就是arguments对象。（这个对象在全局环境中是不存在的）
4. 作用域中的下一个变量对象来自包含环境，在下一个变量对象来自下一个包含环境 ，一直延续到全局执行环境。
5. 全局执行环境的变量对象始终都是作用域链中的最后一个对象。


【标识符解析】：沿着“作用域链”一级一级的搜索“标识符”的过程。
1. 搜索过程始终从作用域链的前段开始，然后逐级的向后回溯，直到找到标识符为止（如果找不到标识符通常会报错）
2. 问：标识符指的是什么？

```javascript
//具体问题具体分析：
//1、
/*var color = "blue";
function changeColor(){
    if(color = "blue"){
        color = "red"
    }else{
        color="blue"
    }
}
changeColor();
console.log("Color is now " + color);*/
/*
就上面的问题而言：
    1、函数changeColor()的作用域链包含两个对象：一个是他自己的变量对象arguments对象，另一个是全局环境的变量对象。
    2、可以在函数内部访问变量color，就因为可以在这个作用域链中找到它、
* */

//2、局部作用域中定义的变量可以在局部环境中与全局变量互换使用。
var color = "blue";
function changeColor() {
    var anotherColor = "red";
    function swapColors() {
        var tempColor = anotherColor;
        anotherColor=color;
        color=tempColor;
        //在这里可以访问tempColor、anotherColor、color
    }
    //在这里可以访问anotherColor、color但不能访问tempColor
    swapColors();
}
//这里只能访问color
changeColor();
/*
*   以上代码涉及到三个执行环境：
*       1、全局环境
*       2、changeColor()局部环境
*       3、swapColor()局部环境
* 总结一句话：子执行环境可以访问它的父执行环境，调用或者修改父执行环境中的变量或者函数；父执行环境不能访问子执行环境。
*
* 也就是说：
* 1、内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。
* 2、内部环境一开始会先在自己的变量对象中搜索变量和函数名，如果搜索不到在搜索上一级作用域链。
*
*
* */
```


